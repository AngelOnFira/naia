use std::{collections::{HashMap, HashSet, VecDeque}, hash::Hash, net::SocketAddr, sync::RwLockReadGuard, time::Duration};

use naia_socket_shared::Instant;

use crate::{messages::channels::receivers::reliable_receiver::ReliableReceiver, sequence_list::SequenceList, types::{HostType, PacketIndex}, world::{
    entity::entity_converters::GlobalWorldManagerType,
    host::host_world_manager::{CommandId, HostWorldManager},
    remote::remote_entity_waitlist::{RemoteEntityWaitlist, WaitlistStore},
    sync::HostEntityChannel,
}, ChannelSender, ComponentKind, ComponentKinds, ComponentUpdate, DiffMask, EntityAndGlobalEntityConverter, EntityAuthStatus, EntityCommand, EntityConverterMut, EntityEvent, EntityMessage, EntityMessageType, GlobalEntity, GlobalEntitySpawner, HostEntity, InScopeEntities, LocalEntityAndGlobalEntityConverter, LocalEntityMap, MessageIndex, OwnedLocalEntity, PacketNotifiable, ReliableSender, RemoteEntity, RemoteWorldManager, Replicate, Tick, WorldMutType, WorldRefType};
use crate::world::update::entity_update_manager::EntityUpdateManager;
use crate::world::sync::RemoteEntityChannel;

const RESEND_COMMAND_RTT_FACTOR: f32 = 1.5;
const COMMAND_RECORD_TTL: Duration = Duration::from_secs(60);

pub struct LocalWorldManager {
    entity_map: LocalEntityMap,
    sender: ReliableSender<EntityCommand>,
    sent_command_packets: SequenceList<(Instant, Vec<(CommandId, EntityMessage<OwnedLocalEntity>)>)>,
    receiver: ReliableReceiver<EntityMessage<OwnedLocalEntity>>,

    host: HostWorldManager,
    remote: RemoteWorldManager,
    updater: EntityUpdateManager,

    // TODO: this is kind of specific to the receiver, put it somewhere else?
    incoming_components: HashMap<(OwnedLocalEntity, ComponentKind), Box<dyn Replicate>>,
    
    // TODO: this is kind of specific to the updater, put it somewhere else?
    incoming_updates: Vec<(Tick, OwnedLocalEntity, ComponentUpdate)>,
}

impl LocalWorldManager {

    pub fn new(
        address: &Option<SocketAddr>,
        host_type: HostType,
        user_key: u64,
        global_world_manager: &dyn GlobalWorldManagerType,
    ) -> Self {
        Self {
            entity_map: LocalEntityMap::new(host_type),
            sender: ReliableSender::new(RESEND_COMMAND_RTT_FACTOR),
            sent_command_packets: SequenceList::new(),
            receiver: ReliableReceiver::new(),

            host: HostWorldManager::new(host_type, user_key),
            remote: RemoteWorldManager::new(host_type),
            updater: EntityUpdateManager::new(address, global_world_manager),

            incoming_components: HashMap::new(),
            incoming_updates: Vec::new(),
        }
    }

    pub(crate) fn entity_waitlist_queue<T>(
        &mut self,
        remote_entity_set: &HashSet<RemoteEntity>,
        waitlist_store: &mut WaitlistStore<T>,
        message: T,
    ) {
        self.remote.entity_waitlist_queue(
            remote_entity_set,
            waitlist_store,
            message,
        );
    }

    // EntityMap-focused

    pub fn entity_converter(&self) -> &dyn LocalEntityAndGlobalEntityConverter {
        self.entity_map.entity_converter()
    }

    pub fn entity_converter_mut<'a, 'b>(
        &'b mut self,
        global_world_manager: &'a dyn GlobalWorldManagerType
    ) -> EntityConverterMut<'a, 'b> {
        self.host.entity_converter_mut(
            global_world_manager,
            &mut self.entity_map,
        )
    }

    pub fn has_global_entity(&self, global_entity: &GlobalEntity) -> bool {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            return false;
        };
        return self.has_local_entity(&local_entity);
    }
    
    pub fn has_local_entity(&self, local_entity: &OwnedLocalEntity) -> bool {
        match local_entity {
            OwnedLocalEntity::Host(host_entity) => self.host.has_entity(&HostEntity::new(*host_entity)),
            OwnedLocalEntity::Remote(remote_entity) => self.remote.has_entity(&RemoteEntity::new(*remote_entity)),
        }
    }
    
    // Host-focused
    
    pub fn has_host_entity(&self, host_entity: &HostEntity) -> bool {
        self.host.has_entity(&host_entity)
    }

    pub fn host_init_entity(
        &mut self,
        global_entity: &GlobalEntity,
        component_kinds: Vec<ComponentKind>,
    ) {
        if self.entity_map.global_entity_to_host_entity(global_entity).is_err() {
            // this is done because `host_reserve_entity()` may have been called previously!
            let host_entity = self.host.host_generate_entity();
            self.entity_map.insert_with_host_entity(*global_entity, host_entity);
        }
        self.host.init_entity_send_host_commands(&self.entity_map, global_entity, component_kinds);
    }

    /// BULLETPROOF: Migrate entity from remote (client) control to host (server) control
    /// 
    /// This method performs a complete, atomic migration of an entity from client control
    /// to server control, including:
    /// - Force-draining all buffered operations
    /// - Preserving component state
    /// - Installing entity redirects
    /// - Updating command references
    /// - Cleaning up old entity channels
    /// 
    /// # Errors
    /// 
    /// This method will panic if:
    /// - The entity doesn't exist in the local entity map
    /// - The entity is not currently remote-owned
    /// - Any step of the migration process fails
    /// 
    /// # Safety
    /// 
    /// This method is designed to be atomic - either the entire migration succeeds
    /// or the system remains in a consistent state. No partial migrations are possible.
    pub fn migrate_entity_remote_to_host(
        &mut self,
        global_entity: &GlobalEntity,
    ) -> HostEntity {
        // BULLETPROOF: Validate entity exists and is remote-owned
        let Some(local_entity_record) = self.entity_map.remove_by_global_entity(global_entity) else {
            panic!("BULLETPROOF ERROR: Attempting to migrate entity which does not exist in local entity map! GlobalEntity: {:?}", global_entity);
        };
        
        if !local_entity_record.is_remote_owned() {
            // Restore the entity record since we removed it
            self.entity_map.insert_with_remote_entity(*global_entity, local_entity_record.remote_entity());
            panic!("BULLETPROOF ERROR: Attempting to migrate entity which is not remote-owned! GlobalEntity: {:?}, Current owner: {:?}", 
                   global_entity, 
                   if local_entity_record.is_host_owned() { "Host" } else { "Unknown" });
        }
        let old_remote_entity = local_entity_record.remote_entity();

        // create new host entity, insert into local entity map
        let new_host_entity = self.host.host_generate_entity();
        self.entity_map.insert_with_host_entity(*global_entity, new_host_entity);

        // BULLETPROOF: Step 1: Force-drain all buffers in RemoteEntityChannel
        // This ensures all pending operations are processed before migration
        self.remote.force_drain_entity_buffers(&old_remote_entity);

        // BULLETPROOF: Step 2: Extract component state from RemoteEntityChannel
        // This preserves the current component state during migration
        let component_kinds = self.remote.extract_component_kinds(&old_remote_entity);

        // BULLETPROOF: Step 3: Remove RemoteEntityChannel from RemoteEngine
        // This must succeed or we're in an inconsistent state
        let _old_remote_channel = self.remote.remove_entity_channel(&old_remote_entity);

        // BULLETPROOF: Step 4: Create new HostEntityChannel with extracted component state
        // This creates the new server-side entity channel with preserved state
        let new_host_channel = HostEntityChannel::new_with_components(
            HostType::Server, // TODO: Get actual host_type from entity_map
            component_kinds
        );

        // BULLETPROOF: Step 5: Insert new HostEntityChannel into HostEngine
        // This must succeed or we lose the entity channel
        self.host.insert_entity_channel(new_host_entity, new_host_channel);

        // BULLETPROOF: Step 6: Install entity redirect in LocalEntityMap
        // This allows old entity references to be automatically updated
        let old_entity = OwnedLocalEntity::Remote(old_remote_entity.value());
        let new_entity = OwnedLocalEntity::Host(new_host_entity.value());
        self.entity_map.install_entity_redirect(old_entity, new_entity);

        // BULLETPROOF: Step 7: Update all references in sent_command_packets
        // This ensures pending commands are sent to the correct entity
        self.update_sent_command_entity_refs(global_entity, old_entity, new_entity);

        // BULLETPROOF: Step 8: Clean up old remote entity
        // This removes the old client-side entity channel
        self.remote.despawn_entity(&mut self.entity_map, &old_remote_entity);

        new_host_entity
    }

    // only server sends this
    pub fn host_send_migrate_response(
        &mut self,
        global_entity: &GlobalEntity,
        new_host_entity: &HostEntity,
    ) {
        let command = EntityCommand::MigrateResponse(None, *global_entity, *new_host_entity);
        self.host.send_command(&self.entity_map, command);
    }

    pub fn host_send_set_auth(
        &mut self,
        global_entity: &GlobalEntity,
        auth_status: EntityAuthStatus,
    ) {
        // TODO: ?
        let command = EntityCommand::SetAuthority(None, *global_entity, auth_status);
        self.host.send_command(&self.entity_map, command);
    }

    pub fn host_reserve_entity(
        &mut self,
        global_entity: &GlobalEntity,
    ) -> HostEntity {
        self.host.host_reserve_entity(&mut self.entity_map, global_entity)
    }

    pub fn host_remove_reserved_entity(
        &mut self,
        global_entity: &GlobalEntity,
    ) -> Option<HostEntity> {
        self.host.host_removed_reserved_entity(global_entity)
    }

    pub(crate) fn insert_sent_command_packet(&mut self, packet_index: &PacketIndex, now: Instant) {
        if !self
            .sent_command_packets
            .contains_scan_from_back(packet_index)
        {
            self
                .sent_command_packets
                .insert_scan_from_back(*packet_index, (now, Vec::new()));
        }
    }

    pub(crate) fn record_command_written(
        &mut self,
        packet_index: &PacketIndex,
        command_id: &CommandId,
        message: EntityMessage<OwnedLocalEntity>,
    ) {
        let (_, sent_actions_list) = self.sent_command_packets.get_mut_scan_from_back(packet_index).unwrap();
        sent_actions_list.push((*command_id, message));
    }

    // Remote-focused

    pub(crate) fn has_remote_entity(&self, remote_entity: &RemoteEntity) -> bool {
        self.remote.has_entity(remote_entity)
    }

    pub fn remote_entities(&self) -> Vec<GlobalEntity> {
        self.entity_map.remote_entities()
    }

    // only client sends this, after receiving enabledelegation message from server
    pub fn send_enable_delegation_response(
        &mut self,
        global_entity: &GlobalEntity,
    ) {
        let command = EntityCommand::EnableDelegationResponse(None, *global_entity);
        self.remote.send_auth_command(&self.entity_map, command);
    }

    pub fn remote_send_request_auth(
        &mut self,
        global_entity: &GlobalEntity,
    ) {
        let command = EntityCommand::RequestAuthority(None, *global_entity);
        self.remote.send_auth_command(&self.entity_map, command);
    }

    pub fn entity_waitlist_mut(&mut self) -> &mut RemoteEntityWaitlist {
        self.remote.entity_waitlist_mut()
    }

    pub(crate) fn receiver_buffer_message(&mut self, id: MessageIndex, msg: EntityMessage<OwnedLocalEntity>) {

        // info!("LocalWorldManager::read(id={}, msg={:?})", id, msg);

        self.receiver.buffer_message(id, msg);
    }

    pub(crate) fn insert_received_component(&mut self, local_entity: &OwnedLocalEntity, component_kind: &ComponentKind, component: Box<dyn Replicate>) {
        self.incoming_components.insert((*local_entity, *component_kind), component);
    }

    pub(crate) fn insert_received_update(
        &mut self,
        tick: Tick,
        local_entity: &OwnedLocalEntity,
        component_update: ComponentUpdate
    ) {
        self.incoming_updates.push((tick, *local_entity, component_update));
    }

    pub fn take_incoming_events<E: Copy + Eq + Hash + Send + Sync, W: WorldMutType<E>>(
        &mut self,
        spawner: &mut dyn GlobalEntitySpawner<E>,
        global_world_manager: &dyn GlobalWorldManagerType,
        component_kinds: &ComponentKinds,
        world: &mut W,
        now: &Instant,
    ) -> Vec<EntityEvent> {
        let incoming_messages = self.receiver.receive_messages();
        let mut incoming_host_messages = Vec::new();
        let mut incoming_remote_messages = Vec::new();
        
        for (id, incoming_message) in incoming_messages {
            if incoming_message.get_type() == EntityMessageType::Noop {
                continue; // skip noop messages
            }
            let Some(local_entity) = incoming_message.entity() else {
                panic!("Received message without an entity! Message: {:?}", incoming_message);
            };
            match local_entity {
                OwnedLocalEntity::Host(host_entity) => {
                    // Host entity message
                    let host_entity = HostEntity::new(host_entity);
                    incoming_host_messages.push((id, incoming_message.with_entity(host_entity)));
                }
                OwnedLocalEntity::Remote(remote_entity) => {
                    // Remote entity message
                    let remote_entity = RemoteEntity::new(remote_entity);
                    incoming_remote_messages.push((id, incoming_message.with_entity(remote_entity)));
                }
            }
        }
        
        let host_events = self.host.take_incoming_events(
            spawner,
            global_world_manager,
            &self.entity_map,
            world,
            incoming_host_messages,
        );
        let mut remote_events = self.remote.take_incoming_events(
            spawner,
            global_world_manager,
            &mut self.entity_map,
            component_kinds,
            world,
            now,
            &mut self.incoming_components,
            std::mem::take(&mut self.incoming_updates),
            incoming_remote_messages
        );

        let mut incoming_events = host_events;
        incoming_events.append(&mut remote_events);

        incoming_events
    }

    pub fn register_authed_entity(
        &mut self,
        global_manager: &dyn GlobalWorldManagerType,
        global_entity: &GlobalEntity,
    ) {
        // info!("Registering authed entity: {:?}", global_entity);
        
        if let Ok(remote_entity) = self.entity_map.global_entity_to_remote_entity(global_entity) {
            self.remote.register_authed_entity(&remote_entity);
        }

        let Some(component_kinds) = global_manager.component_kinds(global_entity) else {
            // entity has no components yet
            return;
        };

        for component_kind in component_kinds.iter() {
            self.updater.register_component(global_entity, component_kind);
        }
    }

    pub fn deregister_authed_entity(
        &mut self,
        global_manager: &dyn GlobalWorldManagerType,
        global_entity: &GlobalEntity,
    ) {
        // info!("Deregistering delegated entity updates for {:?}", global_entity);

        if let Ok(remote_entity) = self.entity_map.global_entity_to_remote_entity(global_entity) {
            self.remote.deregister_authed_entity(&remote_entity);
        }

        let Some(component_kinds) = global_manager.component_kinds(global_entity) else {
            // entity has no components yet
            return;
        };

        for component_kind in component_kinds.iter() {
            self.updater.deregister_component(global_entity, component_kind);
        }
    }

    pub fn remote_spawn_entity(
        &mut self,
        global_entity: &GlobalEntity
    ) {
        let remote_entity = self.entity_map.global_entity_to_remote_entity(global_entity).unwrap();
        self.remote.spawn_entity(&remote_entity);
    }

    pub fn remote_despawn_entity(
        &mut self,
        global_entity: &GlobalEntity,
    ) {
        let remote_entity = self.entity_map.global_entity_to_remote_entity(global_entity).unwrap();
        self.remote.despawn_entity(&mut self.entity_map, &remote_entity);
    }

    // Update-focused

    pub(crate) fn get_diff_mask(&self, global_entity: &GlobalEntity, component_kind: &ComponentKind) -> RwLockReadGuard<'_, DiffMask> {
        self.updater.get_diff_mask(global_entity, component_kind)
    }

    pub(crate) fn record_update(
        &mut self,
        now: &Instant,
        packet_index: &PacketIndex,
        global_entity: &GlobalEntity,
        component_kind: &ComponentKind,
        diff_mask: DiffMask
    ) {
        self.updater.record_update(
            now,
            packet_index,
            global_entity,
            component_kind,
            diff_mask
        );
    }

    // Joint router

    pub fn despawn_entity(&mut self, global_entity: &GlobalEntity) {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to despawn entity which does not exist in local entity map! {:?}", global_entity);
        };
        if local_entity.is_host() {
            self.host.send_command(&self.entity_map, EntityCommand::Despawn(*global_entity));
        } else {
            self.remote.send_entity_command(&self.entity_map, EntityCommand::Despawn(*global_entity));
        }
    }

    pub fn insert_component(
        &mut self,
        global_entity: &GlobalEntity,
        component_kind: &ComponentKind,
    ) {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to insert component for entity which does not exist in local entity map! {:?}", global_entity);
        };
        if local_entity.is_host() {
            self.host.send_command(&self.entity_map, EntityCommand::InsertComponent(*global_entity, *component_kind));
        } else {
            self.remote.send_entity_command(&self.entity_map, EntityCommand::InsertComponent(*global_entity, *component_kind));
        }
    }

    pub fn remove_component(
        &mut self,
        global_entity: &GlobalEntity,
        component_kind: &ComponentKind,
    ) {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to remove component for entity which does not exist in local entity map! {:?}", global_entity);
        };
        if local_entity.is_host() {
            self.host.send_command(&self.entity_map, EntityCommand::RemoveComponent(*global_entity, *component_kind));
        } else {
            self.remote.send_entity_command(&self.entity_map, EntityCommand::RemoveComponent(*global_entity, *component_kind));
        }
    }

    pub fn send_publish(
        &mut self,
        host_type: HostType,
        global_entity: &GlobalEntity,
    ) {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to publish entity which does not exist in local entity map! {:?}", global_entity);
        };
        let host_owned = match (host_type, local_entity.is_host()) {
            (HostType::Server, true) => panic!("Server-owned Entities are published by default, invalid!"),
            (HostType::Client, false) => panic!("Server-owned Entities are published by default, invalid!"),
            (HostType::Server, false) => false, // todo!("server is attempting to publish a client-owned non-public remote entity"),
            (HostType::Client, true) => true, // todo!("client is attempting to publish a client-owned host entity"),
        };

        let command = EntityCommand::Publish(None, *global_entity);
        if host_owned {
            self.host.send_command(&self.entity_map, command);
        } else {
            self.remote.send_auth_command(self.entity_map.entity_converter(), command);
        }
    }

    pub fn send_unpublish(
        &mut self,
        host_type: HostType,
        global_entity: &GlobalEntity,
    ) {
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to publish entity which does not exist in local entity map! {:?}", global_entity);
        };
        let host_owned = match (host_type, local_entity.is_host()) {
            (HostType::Server, true) => panic!("Server-owned Entities cannot be unpublished!"),
            (HostType::Client, false) => panic!("Server-owned Entities cannot be unpublished!"),
            (HostType::Server, false) => false, // todo!("server is attempting to unpublish a client-owned public entity"),
            (HostType::Client, true) => true, // todo!("client is attempting to unpublish a client-owned public entity"),
        };
        let command = EntityCommand::Unpublish(None, *global_entity);
        if host_owned {
            self.host.send_command(&self.entity_map, command);
        } else {
            self.remote.send_auth_command(self.entity_map.entity_converter(), command);
        }
    }

    pub fn send_enable_delegation(
        &mut self,
        host_type: HostType,
        origin_is_owning_client: bool,
        global_entity: &GlobalEntity,
    ) {
        // let is_delegated = self.entity_map.global_entity_is_delegated(global_entity);
        // if is_delegated {
        //     panic!("Entity {:?} is already delegated!", global_entity);
        // }
        let Ok(local_entity) = self.entity_map.global_entity_to_owned_entity(global_entity) else {
            panic!("Attempting to enable delegation for entity which does not exist in local entity map! {:?}", global_entity);
        };
        let host_owned = match (host_type, local_entity.is_host(), origin_is_owning_client) {
            (HostType::Server, false, true) => panic!("Client cannot originate enable delegation for ANOTHER client-owned entity!"),
            (HostType::Client, _, false) => panic!("Client must be the owning client to enable delegation!"),
            (HostType::Client, false, true) => panic!("Client cannot enable delegation for a Server-owned entity"),

            (HostType::Server, true, true) => true,    // todo!("server is proxying client-originating enable delegation message to client (entity should be host-owned here)"),
            (HostType::Server, true, false) => true,   // todo!("server is enabling delegation for a server-owned entity (host owned)"),
            (HostType::Client, true, true) => true,    // todo!("client is attempting to enable delegation for a client-owned entity (host owned)"),
            (HostType::Server, false, false) => false, // todo!("server is attempting to delegate a (hopefully published) client-owned entity (remote-owned entity"),
        };

        let command = EntityCommand::EnableDelegation(None, *global_entity);
        if host_owned {
            self.host.send_command(&self.entity_map, command);
        } else {
            self.remote.send_auth_command(self.entity_map.entity_converter(), command);
        }
    }

    pub fn send_disable_delegation(
        &mut self,
        global_entity: &GlobalEntity,
    ) {
        // only server should ever be able to call this, on host-owned (server-owned) entities
        let command = EntityCommand::DisableDelegation(None, *global_entity);
        self.host.send_command(&self.entity_map, command);
    }

    pub fn remote_send_release_auth(
        &mut self,
        global_entity: &GlobalEntity,
    ) {
        let command = EntityCommand::ReleaseAuthority(None, *global_entity);

        let host_owned = self.entity_map.global_entity_to_owned_entity(global_entity).unwrap().is_host();
        if host_owned {
            self.host.send_command(&self.entity_map, command);
        } else {
            self.remote.send_auth_command(self.entity_map.entity_converter(), command);
        }
    }

    // Joint

    pub fn collect_messages(&mut self, now: &Instant, rtt_millis: &f32) {
        self.handle_dropped_command_packets(now);
        self.updater.handle_dropped_update_packets(now, rtt_millis);
    }

    fn handle_dropped_command_packets(&mut self, now: &Instant) {
        let mut pop = false;

        loop {
            if let Some((_, (time_sent, _))) = self.sent_command_packets.front() {
                if time_sent.elapsed(now) > COMMAND_RECORD_TTL {
                    pop = true;
                }
            } else {
                return;
            }
            if pop {
                self.sent_command_packets.pop_front();
            } else {
                return;
            }
        }
    }

    pub fn take_outgoing_events<E: Copy + Eq + Hash + Send + Sync, W: WorldRefType<E>>(
        &mut self,
        now: &Instant,
        rtt_millis: &f32,
        world: &W,
        converter: &dyn EntityAndGlobalEntityConverter<E>,
        global_world_manager: &dyn GlobalWorldManagerType,
    ) -> (VecDeque<(CommandId, EntityCommand)>, HashMap<GlobalEntity, HashSet<ComponentKind>>) {

        // get outgoing world commands
        let host_commands = self.host.take_outgoing_commands();
        let remote_commands = self.remote.take_outgoing_commands();
        for commands in [host_commands, remote_commands] {
            for command in commands {
                self.sender.send_message(command);
            }
        }
        self.sender.collect_messages(now, rtt_millis);
        let world_commands = self.sender.take_next_messages();

        // get update events
        let update_events = self.take_update_events(world, converter, global_world_manager);

        // return both
        (world_commands, update_events)
    }

    pub fn process_delivered_commands(&mut self) {
        self.host.process_delivered_commands(
            &mut self.entity_map,
            &mut self.updater,
        );
    }

    pub fn take_update_events<E: Copy + Eq + Hash + Send + Sync, W: WorldRefType<E>>(
        &mut self,
        world: &W,
        world_converter: &dyn EntityAndGlobalEntityConverter<E>,
        global_world_manager: &dyn GlobalWorldManagerType,
    ) -> HashMap<GlobalEntity, HashSet<ComponentKind>> {

        let mut updatable_world = self.host.get_updatable_world(&self.entity_map);
        let local_converter = self.entity_map.entity_converter();
        self.remote.append_updatable_world(local_converter, &mut updatable_world);
        self.updater.take_outgoing_events(world, world_converter, global_world_manager, updatable_world)
    }

    // pub(crate) fn get_message_reader_helpers<'a, 'b, 'c, E: Copy + Eq + Hash + Sync + Send>(
    //     &'b mut self,
    //     spawner: &'b mut dyn GlobalEntitySpawner<E>
    // ) -> (GlobalEntityReserver<'a, 'b, 'c, E>, &'a mut EntityWaitlist<RemoteEntity>) {
    //     let remote= &mut self.remote;
    //     let entity_map = &mut self.entity_map;
    //     let reserver = remote.get_message_reader_helpers(entity_map, spawner);
    //     (reserver, remote.entity_waitlist_mut())
    // }

    pub fn get_message_processor_helpers(&mut self) -> (&dyn LocalEntityAndGlobalEntityConverter, &mut RemoteEntityWaitlist) {
        let entity_converter = self.entity_map.entity_converter();
        let entity_waitlist = self.remote.entity_waitlist_mut();
        (entity_converter, entity_waitlist)
    }

    fn host_notify_packet_delivered(&mut self, packet_index: PacketIndex) {
        if let Some((_, command_list)) = self
            .sent_command_packets
            .remove_scan_from_front(&packet_index)
        {
            for (command_id, command) in command_list {
                if self.sender.deliver_message(&command_id).is_some() {
                    self.deliver_message(command_id, command);
                }
            }
        }
    }
    
    fn deliver_message(&mut self, id: CommandId, msg: EntityMessage<OwnedLocalEntity>) {
        let Some(local_entity) = msg.entity() else {
            panic!("Delivered message without an entity! Message: {:?}", msg);
        };
        match local_entity {
            OwnedLocalEntity::Host(host_entity) => {
                // Host entity message
                let host_entity = HostEntity::new(host_entity);
                self.host.deliver_message(id, msg.with_entity(host_entity));
            }
            OwnedLocalEntity::Remote(remote_entity) => {
                // Remote entity message
                let remote_entity = RemoteEntity::new(remote_entity);
                self.remote.deliver_message(id, msg.with_entity(remote_entity));
            }
        }
    }

    fn update_sent_command_entity_refs(
        &mut self,
        _global_entity: &GlobalEntity,
        old_entity: OwnedLocalEntity,
        new_entity: OwnedLocalEntity
    ) {
        // Iterate through sent_command_packets and update entity references
        for (_, (_, commands)) in self.sent_command_packets.iter_mut() {
            for (_, message) in commands.iter_mut() {
                if let Some(entity) = message.entity() {
                    if entity == old_entity {
                        *message = message.clone().with_entity(new_entity);
                    }
                }
            }
        }
    }

    pub fn extract_host_entity_commands(&mut self, global_entity: &GlobalEntity) -> Vec<EntityCommand> {
        // Get host_entity from entity_map
        let host_entity = self.entity_map.global_entity_to_host_entity(global_entity).unwrap();
        // Get host_entity_channel from host engine
        let channel = self.host.get_entity_channel(&host_entity).unwrap();
        // TODO: Need to get mutable reference to extract commands
        Vec::new() // Placeholder until we can get mutable access
    }

    pub fn extract_host_component_kinds(&self, global_entity: &GlobalEntity) -> HashSet<ComponentKind> {
        // Get host_entity from entity_map
        let host_entity = self.entity_map.global_entity_to_host_entity(global_entity).unwrap();
        // Get host_entity_channel from host engine
        let channel = self.host.get_entity_channel(&host_entity).unwrap();
        // Return component_channels clone
        channel.component_kinds().clone()
    }

    pub fn remove_host_entity(&mut self, global_entity: &GlobalEntity) {
        // Remove from entity_map
        self.entity_map.remove_by_global_entity(global_entity);
        // Remove from host engine
        let host_entity = self.entity_map.global_entity_to_host_entity(global_entity).unwrap();
        self.host.remove_entity_channel(&host_entity);
    }

    pub fn insert_remote_entity(
        &mut self,
        global_entity: &GlobalEntity,
        remote_entity: RemoteEntity,
        component_kinds: HashSet<ComponentKind>
    ) {
        // Insert into entity_map
        self.entity_map.insert_with_remote_entity(*global_entity, remote_entity);
        // Create RemoteEntityChannel
        let mut channel = RemoteEntityChannel::new(HostType::Client);
        // Set state to Spawned
        channel.set_spawned(1); // Use dummy message ID
        // For each component_kind, add RemoteComponentChannel with inserted=true
        for component_kind in component_kinds {
            channel.insert_component_channel_as_inserted(component_kind, 1);
        }
        // Insert into remote engine
        self.remote.insert_entity_channel(remote_entity, channel);
    }

    pub fn install_entity_redirect(&mut self, old: OwnedLocalEntity, new: OwnedLocalEntity) {
        self.entity_map.install_entity_redirect(old, new);
    }

    pub fn replay_entity_command(&mut self, global_entity: &GlobalEntity, command: EntityCommand) {
        // Send command through appropriate channel (should be remote after migration)
        let remote_entity = self.entity_map.global_entity_to_remote_entity(global_entity).unwrap();
        self.remote.send_entity_command(&self.entity_map, command);
    }
}

impl PacketNotifiable for LocalWorldManager {
    fn notify_packet_delivered(&mut self, packet_index: PacketIndex) {
        self.host_notify_packet_delivered(packet_index);
        self.updater.notify_packet_delivered(packet_index);
    }
}
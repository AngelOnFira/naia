use std::{
    hash::Hash,
    net::SocketAddr,
    sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard},
};

use crate::{DiffMask, GlobalWorldManagerType, PropertyMutate};

use super::error::WorldChannelError;

pub trait MutChannelType: Send + Sync {
    fn new_receiver(&mut self, address: &Option<SocketAddr>) -> Option<MutReceiver>;
    fn send(&self, diff: u8);
}

// MutChannel
#[derive(Clone)]
pub struct MutChannel {
    data: Arc<RwLock<dyn MutChannelType>>,
}

impl MutChannel {
    pub fn new_channel<E: Copy + Eq + Hash>(
        global_world_manager: &dyn GlobalWorldManagerType<E>,
        diff_mask_length: u8,
    ) -> (MutSender, MutReceiverBuilder) {
        let channel = Self {
            data: global_world_manager.new_mut_channel(diff_mask_length),
        };

        let sender = channel.new_sender();

        let builder = MutReceiverBuilder::new(&channel);

        (sender, builder)
    }

    pub fn new_sender(&self) -> MutSender {
        MutSender::new(self)
    }

    pub fn new_receiver(&self, address: &Option<SocketAddr>) -> Option<MutReceiver> {
        if let Ok(mut data) = self.data.as_ref().write() {
            return data.new_receiver(address);
        }
        None
    }

    pub fn send(&self, diff: u8) -> bool {
        if let Ok(data) = self.data.as_ref().read() {
            data.send(diff);
            return true;
        }
        false
    }
}

// MutReceiver
#[derive(Clone)]
pub struct MutReceiver {
    mask: Arc<RwLock<DiffMask>>,
}

impl MutReceiver {
    pub fn new(diff_mask_length: u8) -> Self {
        Self {
            mask: Arc::new(RwLock::new(DiffMask::new(diff_mask_length))),
        }
    }

    pub fn mask(&self) -> RwLockReadGuard<'_, DiffMask> {
        let Ok(mask) = self.mask.as_ref().read() else {
            panic!("Mask held on current thread");
        };

        mask
    }

    pub fn diff_mask_is_clear(&self) -> bool {
        let Ok(mask) = self.mask.as_ref().read() else {
            panic!("Mask held on current thread");
        };
        return mask.is_clear();
    }

    pub fn mutate(&self, diff: u8) {
        let Ok(mut mask) = self.mask.as_ref().write() else {
            panic!("Mask held on current thread");
        };
        mask.set_bit(diff, true);
    }

    pub fn or_mask(&self, other_mask: &DiffMask) {
        let Ok(mut mask) = self.mask.as_ref().write() else {
            panic!("Mask held on current thread");
        };
        mask.or(other_mask);
    }

    pub fn clear_mask(&self) {
        let Ok(mut mask) = self.mask.as_ref().write() else {
            panic!("Mask held on current thread");
        };
        mask.clear();
    }

    // Try versions that return Result instead of panicking

    pub fn try_mask(&self) -> Result<RwLockReadGuard<'_, DiffMask>, WorldChannelError> {
        self.mask.as_ref().read()
            .map_err(|_| WorldChannelError::RwLockReentrant)
    }

    pub fn try_mask_mut(&self) -> Result<RwLockWriteGuard<'_, DiffMask>, WorldChannelError> {
        self.mask.as_ref().write()
            .map_err(|_| WorldChannelError::RwLockReentrant)
    }

    pub fn try_diff_mask_is_clear(&self) -> Result<bool, WorldChannelError> {
        let mask = self.try_mask()?;
        Ok(mask.is_clear())
    }

    pub fn try_mutate(&self, diff: u8) -> Result<(), WorldChannelError> {
        let mut mask = self.try_mask_mut()?;
        mask.set_bit(diff, true);
        Ok(())
    }

    pub fn try_or_mask(&self, other_mask: &DiffMask) -> Result<(), WorldChannelError> {
        let mut mask = self.try_mask_mut()?;
        mask.or(other_mask);
        Ok(())
    }

    pub fn try_clear_mask(&self) -> Result<(), WorldChannelError> {
        let mut mask = self.try_mask_mut()?;
        mask.clear();
        Ok(())
    }
}

// MutSender
#[derive(Clone)]
pub struct MutSender {
    channel: MutChannel,
}

impl MutSender {
    pub fn new(channel: &MutChannel) -> Self {
        Self {
            channel: channel.clone(),
        }
    }
}

impl PropertyMutate for MutSender {
    fn mutate(&mut self, property_index: u8) -> bool {
        let success = self.channel.send(property_index);
        success
    }
}

// MutReceiverBuilder
pub struct MutReceiverBuilder {
    channel: MutChannel,
}

impl MutReceiverBuilder {
    pub fn new(channel: &MutChannel) -> Self {
        Self {
            channel: channel.clone(),
        }
    }

    pub fn build(&self, address: &Option<SocketAddr>) -> Option<MutReceiver> {
        self.channel.new_receiver(address)
    }
}
